'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/ycc/docs/lab/note/lab1/','title':"实验1 词法分析",'content':"实验1 词法分析   Related files   test.c  (0 ko)    "});index.add({'id':1,'href':'/ycc/docs/lab/summary/','title':"实验综述",'content':"实验综述 在这个实验中，你将要使用Java语言，为C语言的一个子集（我们将其称为YC）编写一个简单的编译器。\n评分标准    实验名称 分数 迟交扣分     Lab1: 词法分析 25 5分/天   Lab2: 语法分析 25 5/天   Lab3: 语义分析 25 3/天   Lab4: 中间代码生成 25 3/天    提交方法 请将的你程序打包成jar包。\n请通过我们的自动评测网站提交你的实现。\n学术诚信声明 我们将严格执行学校的学术诚信政策和程序。\n本课程的所有实验必须由一名学生自行完成。这项工作必须是你自己的。不要从任何人那里复制实验的任何部分。不要看其他学生的代码。不要让任何人可以使用你的部分代码，并确保没有其他人可以读取你的文件。\n您的代码中可以使用通用库，如SML基本库、SML/NJ库或其他公共可用库。这也包括教科书提供的代码。请明确标识您是否使用了库代码，确认其来源，并总结您可能对库所做的任何更改。其他学生本学期或上学期编写编译器是明确禁止使用的。如有疑问，请联系导师。\n本课程的所有作业都是单人作业。这工作一定是你自己做的。不要抄袭任何人的作业的任何部分。不要看其他学生的试卷。不要让任何人知道你的作业的任何部分，并且确保没有人可以阅读你的文件。\n我们将使用Moss系统来检测抄袭行为。\n在实验室、作业或教科书中澄清模糊点，或在使用计算机系统、编译器、调试器、分析器或其他工具时提供帮助或接受帮助，都不被视为作弊。\n "});index.add({'id':2,'href':'/ycc/docs/other/faq/','title':"常见问题",'content':"常见问题 不支持发行版本5\n"});index.add({'id':3,'href':'/ycc/docs/lab/lang-std/lexical/','title':"词法规范",'content':"词法规范 待编写  YC1 以下是YC1的词法规则，使用正则表达式表示。\n   名称 符号     IDENTIFIER [A-Za-z_][A-Za-z0-9_]*   INT_LIT (0|[1-9])[0-9]*   FLOAT_LIT ((0|[1-9])[0-9]*).[0-9]*       名称 符号 名称 符号 名称 符号     ADD + KW_INT int LPAREN (   MINUS - KW_DOUBLE double RPAREN )   MULTI * KW_VOID void LBRACE {   DIV / KW_IF if RBRACE }   GT \u0026gt; KW_ELSE else SEMICOLON ;   GTE \u0026gt;= KW_WHILE while COMMA ,   LT \u0026lt; KW_CONTINUE continue REL_AND \u0026amp;\u0026amp;   LTE \u0026lt;= KW_BREAK break REL_OR ||   EQ == KW_RETURN return REL_NOT !   NEQ !=       ASSIGN =        YC2 新增单词类型如下\n   名称 符号     LBRACKET [   RBRACKET ]   KW_FOR for    "});index.add({'id':4,'href':'/ycc/docs/other/reference/','title':"参考资料",'content':"参考资料 这里是你可以参考的相似项目和相关资料，欢迎补充。\n课程实验  伯克利的CS164: Programming Languages and Compilers, Spring 2019 斯坦福的CS143: Compilers CMU的15-411 Compiler Design 清华的Decaf  开源编译器\u0026amp;解释器  wenyan: 文言文编程 Wren Pony SmallerC 8cc ShivyC: Python实现的C语言编译器。 xcc wgtcc: C++实现的C语言编译器, 代码写的不错。 Enkel: 基于Java, Antlr的语言，编译成Java字节码，有文字教程。 c4: C语言实现的C编译器，非常精简, 只有四个函数, 支持自举。 xc: 修改自C4, 提供中文教程。 finch: 自制的动态语言, 使用C++编写  电子书  Lox解释器及其配套电子书  源码: https://github.com/munificent/craftinginterpreters   Introduction to Compilers and Language Design  配套代码: https://github.com/dthain/compilerbook-examples   A small demonstration how to use ANTLR 4\u0026rsquo;s visitor feature. PCAsm  其他资料 以下为未经挑选的资料，部分挑选的资料可能与上面的重复。\n (any): mal - Make a Lisp Assembly: Jonesforth C: Baby\u0026rsquo;s First Garbage Collector C: Build Your Own Lisp: Learn C and build your own programming language in 1000 lines of code C: Writing a Simple Garbage Collector in C C: C interpreter that interprets itself. C: A C \u0026amp; x86 version of the \u0026ldquo;Let\u0026rsquo;s Build a Compiler\u0026rdquo; by Jack Crenshaw C++: Writing Your Own Toy Compiler Using Flex C++: How to Create a Compiler [video] C++: Kaleidoscope: Implementing a Language with LLVM F#: Understanding Parser Combinators Elixir: Demystifying compilers by writing your own [video] Go: The Super Tiny Compiler Go: Lexical Scanning in Go [video] Haskell: Let\u0026rsquo;s Build a Compiler Haskell: Write You a Haskell Haskell: Write Yourself a Scheme in 48 Hours Haskell: Write You A Scheme Java: Crafting interpreters: A handbook for making programming languages Java: Creating JVM Language JavaScript: The Super Tiny Compiler JavaScript: The Super Tiny Interpreter JavaScript: Little Lisp interpreter JavaScript: How to implement a programming language in JavaScript OCaml: Writing a C Compiler OCaml: Writing a Lisp, the series Pascal: Let\u0026rsquo;s Build a Compiler Python: A Python Interpreter Written in Python Python: lisp.py: Make your own Lisp interpreter Python: Simple Iterator-based Parsing Python: Simple Top-Down Parsing in Python Python: How to Write a Lisp Interpreter in Python Python: Let’s Build A Simple Interpreter Python: Make Your Own Simple Interpreted Programming Language [video] Racket: Beautiful Racket: How to make your own programming languages with Racket Ruby: A Compiler From Scratch Ruby: Markdown compiler from scratch in Ruby Rust: So You Want to Build a Language VM Rust: Learning Parser Combinators With Rust Swift: Building a LISP from scratch with Swift TypeScript: Build your own WebAssembly Compiler  "});index.add({'id':5,'href':'/ycc/docs/lab/note/lab2/','title':"实验2 语法分析",'content':"实验2 语法分析  Get Home  Contribute  "});index.add({'id':6,'href':'/ycc/docs/lab/lang-std/grammar/','title':"语法规范",'content':"语法规范 编写中  我们使用扩展BNF范式描述我们的文法。\n 以下内容修改自Decaf语言规范。\n * 表示一个符号出现任意多次，包括零次 + 表示一个符号出现至少一次 ? 表示一个符号可选，即至多出现一次 | 分隔多个产生式右部，无顺序 ε 表示空，即不存在任何符号  所有终结符要么以单引号字符串的形式直接出现，或者用以全大写字母的标识符代替，非终结符对应的标识符均以大写字母开头,并使用驼峰命名法。此外，我们还使用 () 来显式限定上述元符号作用的符号或者符号串。\n YC1 终结符的词法规则见词法规范 | YC1。\n为了让文法尽可能的简单，我们没有将许多语义显示的注入文法当中。对于详细的语义要求，如表达式优先级等，请查看语义说明 | YC1。\n/* 程序结构 */ Program ::= Decl* Decl ::= VarDecl | FuncDecl Block ::= Stmt* Stmt ::= VarDecl | ExprStmt | IfStmt | WhileStmt | ReturnStmt | EmptyStmt EmptyStmt ::= \u0026#39;;\u0026#39; /* 变量 */ VarDecl ::= Type Id \u0026#39;=\u0026#39; Expr \u0026#39;;\u0026#39; Type ::= \u0026#39;int\u0026#39; | \u0026#39;float\u0026#39; | \u0026#39;void\u0026#39; /* 表达式 */ Expr ::= \u0026#39;(\u0026#39; Expr \u0026#39;)\u0026#39; // 括号表达式 | Literal // 常量, 如1.34, 10 | Id // 标识符也是表达式 | FunCall // 函数调用 | UnaryExpr // 一元表达式 | BinaryExpr // 二元表达式 | TypeCastExpr // 类型转换 Literal ::= INT_LIT | FLOAT_LIT Id ::= IDENTIFIER FunCall ::= Id \u0026#39;(\u0026#39; ArgList \u0026#39;)\u0026#39; ArgList ::= Expr ((\u0026#39;,\u0026#39; Expr)* | ε) // 实参列表 UnaryExpr ::= UnaryOp Expression UnaryOp ::= \u0026#39;-\u0026#39; | \u0026#39;!\u0026#39; BinaryExpr ::= Expr BinaryOp Expr BinaryOp ::= \u0026#39;*\u0026#39; | \u0026#39;/\u0026#39; | \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;\u0026gt;\u0026#39; | \u0026#39;\u0026gt;=\u0026#39; | \u0026#39;\u0026lt;\u0026#39; | \u0026#39;\u0026lt;=\u0026#39; | \u0026#39;==\u0026#39; | \u0026#39;!=\u0026#39; | \u0026#39;=\u0026#39; | \u0026#39;\u0026amp;\u0026amp;\u0026#39; | \u0026#39;||\u0026#39; TypeCastExpr ::= \u0026#39;(\u0026#39; Type \u0026#39;)\u0026#39; Expression /* 分支 */ IfStmt ::= \u0026#39;if\u0026#39; \u0026#39;(\u0026#39; Expr \u0026#39;)\u0026#39; Block ( \u0026#39;else\u0026#39; Block )? /* 循环 */ WhileStmt ::= \u0026#39;while\u0026#39; \u0026#39;(\u0026#39; Expr \u0026#39;)\u0026#39; Block ContinueStmt ::= \u0026#39;continue\u0026#39; \u0026#39;;\u0026#39; BreakStmt ::= \u0026#39;break\u0026#39; \u0026#39;;\u0026#39; /* 函数 */ FuncDecl ::= Type Id \u0026#39;(\u0026#39; ParaList \u0026#39;)\u0026#39; Block ParaList ::= Para ((\u0026#39;,\u0026#39; Para)* | ε) // 形参列表 Para ::= Type Id ReturnStmt ::= \u0026#39;return\u0026#39; Expression? \u0026#39;;\u0026#39; YC2 数组文法如下:\nVarDecl ::= Type Id(\u0026#39;[\u0026#39; INT_LIT \u0026#39;]\u0026#39;)* (\u0026#39;=\u0026#39; Expr)* \u0026#39;;\u0026#39; LValue ::= Id 新增For循环文法如下：\n`for` `(`VarDecl `)` "});index.add({'id':7,'href':'/ycc/docs/announcements/','title':"重要通知",'content':"重要通知 2020-3-21  发布实验框架0.1-beta版，支持词法，语法分析。  "});index.add({'id':8,'href':'/ycc/docs/lab/lang-std/semantic/','title':"语义说明",'content':"语义说明 编写中  YC1 在语言规范一章中，我们已经说了，YC1的文法是C语言文法的一个子集，因此YC1程序也是C语言程序。本节主要阐述YC1语言相对于C语言的一些特殊规定。\n程序结构 一个YC1程序由数个声明（Declaration）构成，声明包括函数声明和变量声明。\n变量 还记得C语言是怎么定义变量的吗？我们的YC语言与你之前所学的没有什么不同，例如，你可以像下面这样定义YC语言中的变量。\nint a = 10; // 定义一个名叫a的整型变量，并赋初值为10 double b = 3.14; // 定义一个名叫a的双精度浮点型变量，并赋初值为3.14 但是，为了简单请见，在YC1中，我们对变量定义做了一些限制。\n YC1只支持有限的3种数据类型，分别是int, float, void,（void只能作为函数返回值的类型）。 所有变量必须在定义的时候初始化。 一次只能定义一个变量。  关于上述要求，以下是几个例子:\nchar a = \u0026#39;c\u0026#39; // 不合法: 不支持char类型 int b = 10; // 合法 int c; // 不合法: 变量必须在定义的时候初始化 double d=10, e=9; // 不合法: 一次只能定义一个变量 表达式 诸如加减乘除，比较大小等运算的\u0008语句都被称为表达式。C语言支持相当多的表达式，如算术表达式，比较表达式，甚至位运算表达式，但是为了简便请见，YC1只支持部分基础的表达式，其他表达式将作为后续版本的扩展内容。\nYC1支持的表达式按优先级从高到低如下表所示:\n   语义 运算符 结合性 例子     括号 () 无 (a+b)   函数调用 () 左结合 f(10)   相反数,类型转换, 取反 - (type) ! 右结合 -10, (int)3.14, !(a\u0026gt;b)   乘除 * / 左结合 3*9, 10/2   加减 + - 左结合 3+10, 4-9   大小比较 \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= 左结合 a\u0026gt;b, a\u0026gt;=b, c\u0026lt;d, c\u0026lt;=d   相等比较 == != 左结合 a==b, a!=b   关系与 \u0026amp;\u0026amp; 左结合 a\u0026gt;0\u0026amp;\u0026amp;b\u0026gt;0   关系或 || 左结合 a\u0026gt;0   赋值 = 右结合 a=b, a=b=c    分支 YC1只支持if分支语句，不支持switch和goto。\n 每个if语句，可能包含一个else语句，但YC1不支持else if语句。 if或else里的内容必须使用大括号包裹，即使里面只有一个语句。  合法例子:\nif(a\u0026lt;0) { a = a+1; } if(a\u0026lt;0) { a = a+1; } else { b = b-1; }   不合法例子:\nif(a==2) { a=1; } else if(a==3) { a=3; } // 不支持else if  // 即使只有一个语句也必须使用大括号 if(a==4) a = 3;    循环 YC1只支持while循环，for和do while循环为后续版本的扩展内容。\n 与if一样, while循环的循环体必须使用大括号包裹，即使里面只有一条语句。  函数 YC1支持函数，但是与C语言不同的是，YC1不能只定义函数声明而不实现，函数调用只能通过f(1,2,3)的形式调用，不能通过函数指针。\n 什么是函数声明? ↕  在c语言中下面的语句是合法的, 函数声明只有函数签名而没有函数体。\nint add(int x, int y); int add(int, int); // 你甚至可以不写形参的名字 上述语法在YC1中是不允许的。\n   以下是一个合法的函数定义和调用。\nint add(int x, int y) { return x+y; } // 与C类似, 你必须定义一个名叫main的主函数作为程序入口 int main() { int c = add(1,2); return 0; } YC2 数组 For循环 "});index.add({'id':9,'href':'/ycc/docs/lab/','title':"实验",'content':""});index.add({'id':10,'href':'/ycc/docs/lab/note/','title':"实验说明",'content':"Ubi loqui Mentem genus facietque salire tempus bracchia Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':11,'href':'/ycc/docs/framework-tutorial/','title':"框架指导",'content':""});index.add({'id':12,'href':'/ycc/docs/lab/lang-std/cheatsheet/','title':"特性汇总",'content':"特性汇总 这里以最简洁的形式汇总了YC语言各个版本支持的特性。\n"});index.add({'id':13,'href':'/ycc/docs/lab/lang-std/','title':"语言规范",'content':"语言规范 YC1语言\u0008与C语言非常接近，但是YC语言被设计的比C语言更为简单，因为你们需要为这个语言编写一个编译器。\n我们大幅精简并修改了部分C语言的语法形成YC语言。大部分YC语言的语法都可以用LL(1)文法进行描述，\u0008我们希望这个更为简单的\u0026quot;C语言\u0026quot;能够帮助你们在这个学期内及时的完成整个实验并掌握编写一个编译器所必要的知识和技巧。  为了\u0008让你们能够更快速的编写你的编译器，我们删除了许多C语言中比较复杂或不常用的语法，如：\n 预处理指令与宏：YC语言只支持单文件编译，不支持宏。 复杂的类型系统：YC语言只支持有限的几种数据类型。 复杂的指针用法：YC语言只支持有限的指针使用方法（指针为扩展内容）。 \u0026hellip;  为满足不同层次学生的需求，我们为YC语言制定了多个版本，每个版本都会在前一个版本添加一些新特性。所有学生只要求完成YC1这个版本，后面的版本将提供给学有余力的同学完成。\n YC1 YC1是C语言的一个子集(一个合法的YC1程序一定是一个合法的C程序，你可以使用任何一个C语言编译器编译YC1的程序)。\n这个版本包含了YC语言的基础语法，如变量，函数，循环，分支，表达式等。\n  词法规范 语法规范 语义说明     YC2 YC2仍然是C语言的一个子集。\n这个版本新增了数组和for循环。\n  词法规范 语法规范 语义说明    开发中\u0026hellip;    YC是Yan C的缩写。 \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':14,'href':'/ycc/docs/other/','title':"其他",'content':""});index.add({'id':15,'href':'/ycc/docs/lab/lang-std/new-features/','title':"新特性提案",'content':"新特性提案 此页面还在撰写中\u0026hellip;  这个页面包含了可能会添加进下一个版本中的语言新特性。\n新特性池  struct 字符串  开发周期 为了保证学生能够较好的完成实验，我们对添加进入YC语言的特性十分的谨慎。这也是为什么我们采用多个版本迭代的方式进行语言特性的选取与开发。\n一般来说，所有学生只被要求实现YC语言前几个版本的特性（现在是YC1），\u0008学有余力的同学可以选择继续实现后面的版本。随着版本不断的更新，以后实验可能转向由我们提供编译器的基础实现（YC1），然后由学生实现新特性（YC1～YCn） -\u0026gt; 待定。\n开发周期按学年进行，基本流程如下：\n  特性征集：根据学生，开发组提议内容形成一个新特性池。\n  选取特性：周期初由所有开发组成员从新特性池中选取数个新特性。\n  标准编译器与框架的开发： 在上一个版本的标准编译器中\u0008实现新特性，并更新相应自动评测，实验框架代码。\n  特性冻结：在每年的编译原理实验开始前两周对特性进行冻结，已经实现完成的特性准备发布，未实现的特性顺延至下一个周期。\n  集成测试：特性冻结之后，对所有待发布的特性进行一次充分的测试。\n  补充文档：完善必要的文档，包括主站，文档站和实验站。\n  发布新版本：将新版本发布至\u0008Github Release和Maven中央仓库。\n    graph TD; 特性征集--选取特性; 选取特性--标准编译器开发; 选取特性--自动评测开发; 选取特性--框架开发; 标准编译器开发--特性冻结; 自动评测开发--特性冻结; 框架开发--特性冻结; 特性冻结--集成测试; 集成测试--补充文档; 补充文档--新版本发布;   "});index.add({'id':16,'href':'/ycc/docs/framework-tutorial/java/','title':"Java",'content':"Java框架指导 在本次课程的一系列实验中，你不需要也不应该自行编写整个编译器，我们提供一个编译器框架供你使用。\n目前只有通过这个框架编写的编译器才能够通过我们提供的自动评测系统完成评测，所以现阶段你必须使用该框架完成编译器的构建。  准备资料 该框架使用Java编写，以第三方库的形式发布，为了使用框架完成本次实验，你需要安装以下软件：\n JDK11或更高版本：框架使用Java11编写，因此你需要安装JDK11或更高版本。 Maven：实验提供的模板项目使用Maven管理依赖，如果你选择使用模板的话你需要安装这个。 Git：推荐使用Git进行版本控制，不是强制要求。 Intellij IDEA：推荐使用IDEA作为你的集成开发环境，社区版即可。这不是强制要求，你也可以使用eclipse。  快速开始 下载IDEA模板项目：  模板项目是使用Idea创建的Maven项目，该模板是帮你写好了Maven的配置文件，然后写了一个主类。你下载下来的项目应该有下面这样的文件结构：\n. ├── pom.xml ├── src │ ├── main │ │ ├── java │ │ │ └── yan │ │ │ └── ycc │ │ │ └── impl │ │ │ └── Main.java │ │ └── resources │ │ └── META-INF │ │ └── MANIFEST.MF │ └── test │ └── java └── ycc-template.iml 打开Main.java，你会发现里面已经写了一些代码了。这三行代码是使用我们的实验框架的最基础的代码。通过这三行代码，你可以得到一个具有命令行解析能力以及多功能解释器（REPL）的编译器\u0026amp;解释器（虽然还不能执行任何编译任务）。\npackage yan.ycc.impl; import yan.foundation.driver.Launcher; import yan.ycc.api.YCLang; public class Main { public static void main(String[] args) { YCLang lang = new YCLang(new TaskFactoryImpl()); Launcher.instance(lang).commandName(\u0026#34;ycc\u0026#34;).launch(args); } public static class TaskFactoryImpl implements YCLang.TaskFactory {} } 如果你使用IDEA，你可以点击Main旁边的绿色箭头编译运行整个项目。然后你会在控制台看到以下信息（提示缺少输入文件，事实上就是代码）。\nMissing required parameter: \u0026lt;inputFile\u0026gt; Usage: ycc [-hV] [-o=\u0026lt;outputFile\u0026gt;] [-t=\u0026lt;targetName\u0026gt;] \u0026lt;inputFile\u0026gt; \u0026lt;inputFile\u0026gt; The file to be processed. -h, --help Show this help message and exit. -o, --output=\u0026lt;outputFile\u0026gt; Output file for result -t, --target=\u0026lt;targetName\u0026gt; The stage you want to compile to. Valid values: . Default: null -V, --version Print version information and exit. 如果你以命令行的方式运行编译\n"});index.add({'id':17,'href':'/ycc/docs/framework-tutorial/java/lexer/','title':"Lab1 词法分析器",'content':"词法分析器 "});index.add({'id':18,'href':'/ycc/docs/framework-tutorial/java/parser/','title':"Lab2 语法分析器",'content':"语法分析器 "});})();